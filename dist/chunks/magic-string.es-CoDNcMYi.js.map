{"version":3,"file":"magic-string.es-CoDNcMYi.js","sources":["../../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js","../../node_modules/magic-string/dist/magic-string.es.mjs"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.sourcemapCodec = {}));\n})(this, (function (exports) { 'use strict';\n\n    const comma = ','.charCodeAt(0);\n    const semicolon = ';'.charCodeAt(0);\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    const intToChar = new Uint8Array(64); // 64 possible chars.\n    const charToInt = new Uint8Array(128); // z is 122 in ASCII\n    for (let i = 0; i < chars.length; i++) {\n        const c = chars.charCodeAt(i);\n        intToChar[i] = c;\n        charToInt[c] = i;\n    }\n    function decodeInteger(reader, relative) {\n        let value = 0;\n        let shift = 0;\n        let integer = 0;\n        do {\n            const c = reader.next();\n            integer = charToInt[c];\n            value |= (integer & 31) << shift;\n            shift += 5;\n        } while (integer & 32);\n        const shouldNegate = value & 1;\n        value >>>= 1;\n        if (shouldNegate) {\n            value = -0x80000000 | -value;\n        }\n        return relative + value;\n    }\n    function encodeInteger(builder, num, relative) {\n        let delta = num - relative;\n        delta = delta < 0 ? (-delta << 1) | 1 : delta << 1;\n        do {\n            let clamped = delta & 0b011111;\n            delta >>>= 5;\n            if (delta > 0)\n                clamped |= 0b100000;\n            builder.write(intToChar[clamped]);\n        } while (delta > 0);\n        return num;\n    }\n    function hasMoreVlq(reader, max) {\n        if (reader.pos >= max)\n            return false;\n        return reader.peek() !== comma;\n    }\n\n    const bufLength = 1024 * 16;\n    // Provide a fallback for older environments.\n    const td = typeof TextDecoder !== 'undefined'\n        ? /* #__PURE__ */ new TextDecoder()\n        : typeof Buffer !== 'undefined'\n            ? {\n                decode(buf) {\n                    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n                    return out.toString();\n                },\n            }\n            : {\n                decode(buf) {\n                    let out = '';\n                    for (let i = 0; i < buf.length; i++) {\n                        out += String.fromCharCode(buf[i]);\n                    }\n                    return out;\n                },\n            };\n    class StringWriter {\n        constructor() {\n            this.pos = 0;\n            this.out = '';\n            this.buffer = new Uint8Array(bufLength);\n        }\n        write(v) {\n            const { buffer } = this;\n            buffer[this.pos++] = v;\n            if (this.pos === bufLength) {\n                this.out += td.decode(buffer);\n                this.pos = 0;\n            }\n        }\n        flush() {\n            const { buffer, out, pos } = this;\n            return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n        }\n    }\n    class StringReader {\n        constructor(buffer) {\n            this.pos = 0;\n            this.buffer = buffer;\n        }\n        next() {\n            return this.buffer.charCodeAt(this.pos++);\n        }\n        peek() {\n            return this.buffer.charCodeAt(this.pos);\n        }\n        indexOf(char) {\n            const { buffer, pos } = this;\n            const idx = buffer.indexOf(char, pos);\n            return idx === -1 ? buffer.length : idx;\n        }\n    }\n\n    const EMPTY = [];\n    function decodeOriginalScopes(input) {\n        const { length } = input;\n        const reader = new StringReader(input);\n        const scopes = [];\n        const stack = [];\n        let line = 0;\n        for (; reader.pos < length; reader.pos++) {\n            line = decodeInteger(reader, line);\n            const column = decodeInteger(reader, 0);\n            if (!hasMoreVlq(reader, length)) {\n                const last = stack.pop();\n                last[2] = line;\n                last[3] = column;\n                continue;\n            }\n            const kind = decodeInteger(reader, 0);\n            const fields = decodeInteger(reader, 0);\n            const hasName = fields & 0b0001;\n            const scope = (hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind]);\n            let vars = EMPTY;\n            if (hasMoreVlq(reader, length)) {\n                vars = [];\n                do {\n                    const varsIndex = decodeInteger(reader, 0);\n                    vars.push(varsIndex);\n                } while (hasMoreVlq(reader, length));\n            }\n            scope.vars = vars;\n            scopes.push(scope);\n            stack.push(scope);\n        }\n        return scopes;\n    }\n    function encodeOriginalScopes(scopes) {\n        const writer = new StringWriter();\n        for (let i = 0; i < scopes.length;) {\n            i = _encodeOriginalScopes(scopes, i, writer, [0]);\n        }\n        return writer.flush();\n    }\n    function _encodeOriginalScopes(scopes, index, writer, state) {\n        const scope = scopes[index];\n        const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;\n        if (index > 0)\n            writer.write(comma);\n        state[0] = encodeInteger(writer, startLine, state[0]);\n        encodeInteger(writer, startColumn, 0);\n        encodeInteger(writer, kind, 0);\n        const fields = scope.length === 6 ? 0b0001 : 0;\n        encodeInteger(writer, fields, 0);\n        if (scope.length === 6)\n            encodeInteger(writer, scope[5], 0);\n        for (const v of vars) {\n            encodeInteger(writer, v, 0);\n        }\n        for (index++; index < scopes.length;) {\n            const next = scopes[index];\n            const { 0: l, 1: c } = next;\n            if (l > endLine || (l === endLine && c >= endColumn)) {\n                break;\n            }\n            index = _encodeOriginalScopes(scopes, index, writer, state);\n        }\n        writer.write(comma);\n        state[0] = encodeInteger(writer, endLine, state[0]);\n        encodeInteger(writer, endColumn, 0);\n        return index;\n    }\n    function decodeGeneratedRanges(input) {\n        const { length } = input;\n        const reader = new StringReader(input);\n        const ranges = [];\n        const stack = [];\n        let genLine = 0;\n        let definitionSourcesIndex = 0;\n        let definitionScopeIndex = 0;\n        let callsiteSourcesIndex = 0;\n        let callsiteLine = 0;\n        let callsiteColumn = 0;\n        let bindingLine = 0;\n        let bindingColumn = 0;\n        do {\n            const semi = reader.indexOf(';');\n            let genColumn = 0;\n            for (; reader.pos < semi; reader.pos++) {\n                genColumn = decodeInteger(reader, genColumn);\n                if (!hasMoreVlq(reader, semi)) {\n                    const last = stack.pop();\n                    last[2] = genLine;\n                    last[3] = genColumn;\n                    continue;\n                }\n                const fields = decodeInteger(reader, 0);\n                const hasDefinition = fields & 0b0001;\n                const hasCallsite = fields & 0b0010;\n                const hasScope = fields & 0b0100;\n                let callsite = null;\n                let bindings = EMPTY;\n                let range;\n                if (hasDefinition) {\n                    const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);\n                    definitionScopeIndex = decodeInteger(reader, definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0);\n                    definitionSourcesIndex = defSourcesIndex;\n                    range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex];\n                }\n                else {\n                    range = [genLine, genColumn, 0, 0];\n                }\n                range.isScope = !!hasScope;\n                if (hasCallsite) {\n                    const prevCsi = callsiteSourcesIndex;\n                    const prevLine = callsiteLine;\n                    callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);\n                    const sameSource = prevCsi === callsiteSourcesIndex;\n                    callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);\n                    callsiteColumn = decodeInteger(reader, sameSource && prevLine === callsiteLine ? callsiteColumn : 0);\n                    callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];\n                }\n                range.callsite = callsite;\n                if (hasMoreVlq(reader, semi)) {\n                    bindings = [];\n                    do {\n                        bindingLine = genLine;\n                        bindingColumn = genColumn;\n                        const expressionsCount = decodeInteger(reader, 0);\n                        let expressionRanges;\n                        if (expressionsCount < -1) {\n                            expressionRanges = [[decodeInteger(reader, 0)]];\n                            for (let i = -1; i > expressionsCount; i--) {\n                                const prevBl = bindingLine;\n                                bindingLine = decodeInteger(reader, bindingLine);\n                                bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);\n                                const expression = decodeInteger(reader, 0);\n                                expressionRanges.push([expression, bindingLine, bindingColumn]);\n                            }\n                        }\n                        else {\n                            expressionRanges = [[expressionsCount]];\n                        }\n                        bindings.push(expressionRanges);\n                    } while (hasMoreVlq(reader, semi));\n                }\n                range.bindings = bindings;\n                ranges.push(range);\n                stack.push(range);\n            }\n            genLine++;\n            reader.pos = semi + 1;\n        } while (reader.pos < length);\n        return ranges;\n    }\n    function encodeGeneratedRanges(ranges) {\n        if (ranges.length === 0)\n            return '';\n        const writer = new StringWriter();\n        for (let i = 0; i < ranges.length;) {\n            i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);\n        }\n        return writer.flush();\n    }\n    function _encodeGeneratedRanges(ranges, index, writer, state) {\n        const range = ranges[index];\n        const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, isScope, callsite, bindings, } = range;\n        if (state[0] < startLine) {\n            catchupLine(writer, state[0], startLine);\n            state[0] = startLine;\n            state[1] = 0;\n        }\n        else if (index > 0) {\n            writer.write(comma);\n        }\n        state[1] = encodeInteger(writer, range[1], state[1]);\n        const fields = (range.length === 6 ? 0b0001 : 0) | (callsite ? 0b0010 : 0) | (isScope ? 0b0100 : 0);\n        encodeInteger(writer, fields, 0);\n        if (range.length === 6) {\n            const { 4: sourcesIndex, 5: scopesIndex } = range;\n            if (sourcesIndex !== state[2]) {\n                state[3] = 0;\n            }\n            state[2] = encodeInteger(writer, sourcesIndex, state[2]);\n            state[3] = encodeInteger(writer, scopesIndex, state[3]);\n        }\n        if (callsite) {\n            const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite;\n            if (sourcesIndex !== state[4]) {\n                state[5] = 0;\n                state[6] = 0;\n            }\n            else if (callLine !== state[5]) {\n                state[6] = 0;\n            }\n            state[4] = encodeInteger(writer, sourcesIndex, state[4]);\n            state[5] = encodeInteger(writer, callLine, state[5]);\n            state[6] = encodeInteger(writer, callColumn, state[6]);\n        }\n        if (bindings) {\n            for (const binding of bindings) {\n                if (binding.length > 1)\n                    encodeInteger(writer, -binding.length, 0);\n                const expression = binding[0][0];\n                encodeInteger(writer, expression, 0);\n                let bindingStartLine = startLine;\n                let bindingStartColumn = startColumn;\n                for (let i = 1; i < binding.length; i++) {\n                    const expRange = binding[i];\n                    bindingStartLine = encodeInteger(writer, expRange[1], bindingStartLine);\n                    bindingStartColumn = encodeInteger(writer, expRange[2], bindingStartColumn);\n                    encodeInteger(writer, expRange[0], 0);\n                }\n            }\n        }\n        for (index++; index < ranges.length;) {\n            const next = ranges[index];\n            const { 0: l, 1: c } = next;\n            if (l > endLine || (l === endLine && c >= endColumn)) {\n                break;\n            }\n            index = _encodeGeneratedRanges(ranges, index, writer, state);\n        }\n        if (state[0] < endLine) {\n            catchupLine(writer, state[0], endLine);\n            state[0] = endLine;\n            state[1] = 0;\n        }\n        else {\n            writer.write(comma);\n        }\n        state[1] = encodeInteger(writer, endColumn, state[1]);\n        return index;\n    }\n    function catchupLine(writer, lastLine, line) {\n        do {\n            writer.write(semicolon);\n        } while (++lastLine < line);\n    }\n\n    function decode(mappings) {\n        const { length } = mappings;\n        const reader = new StringReader(mappings);\n        const decoded = [];\n        let genColumn = 0;\n        let sourcesIndex = 0;\n        let sourceLine = 0;\n        let sourceColumn = 0;\n        let namesIndex = 0;\n        do {\n            const semi = reader.indexOf(';');\n            const line = [];\n            let sorted = true;\n            let lastCol = 0;\n            genColumn = 0;\n            while (reader.pos < semi) {\n                let seg;\n                genColumn = decodeInteger(reader, genColumn);\n                if (genColumn < lastCol)\n                    sorted = false;\n                lastCol = genColumn;\n                if (hasMoreVlq(reader, semi)) {\n                    sourcesIndex = decodeInteger(reader, sourcesIndex);\n                    sourceLine = decodeInteger(reader, sourceLine);\n                    sourceColumn = decodeInteger(reader, sourceColumn);\n                    if (hasMoreVlq(reader, semi)) {\n                        namesIndex = decodeInteger(reader, namesIndex);\n                        seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];\n                    }\n                    else {\n                        seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];\n                    }\n                }\n                else {\n                    seg = [genColumn];\n                }\n                line.push(seg);\n                reader.pos++;\n            }\n            if (!sorted)\n                sort(line);\n            decoded.push(line);\n            reader.pos = semi + 1;\n        } while (reader.pos <= length);\n        return decoded;\n    }\n    function sort(line) {\n        line.sort(sortComparator);\n    }\n    function sortComparator(a, b) {\n        return a[0] - b[0];\n    }\n    function encode(decoded) {\n        const writer = new StringWriter();\n        let sourcesIndex = 0;\n        let sourceLine = 0;\n        let sourceColumn = 0;\n        let namesIndex = 0;\n        for (let i = 0; i < decoded.length; i++) {\n            const line = decoded[i];\n            if (i > 0)\n                writer.write(semicolon);\n            if (line.length === 0)\n                continue;\n            let genColumn = 0;\n            for (let j = 0; j < line.length; j++) {\n                const segment = line[j];\n                if (j > 0)\n                    writer.write(comma);\n                genColumn = encodeInteger(writer, segment[0], genColumn);\n                if (segment.length === 1)\n                    continue;\n                sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);\n                sourceLine = encodeInteger(writer, segment[2], sourceLine);\n                sourceColumn = encodeInteger(writer, segment[3], sourceColumn);\n                if (segment.length === 4)\n                    continue;\n                namesIndex = encodeInteger(writer, segment[4], namesIndex);\n            }\n        }\n        return writer.flush();\n    }\n\n    exports.decode = decode;\n    exports.decodeGeneratedRanges = decodeGeneratedRanges;\n    exports.decodeOriginalScopes = decodeOriginalScopes;\n    exports.encode = encode;\n    exports.encodeGeneratedRanges = encodeGeneratedRanges;\n    exports.encodeOriginalScopes = encodeOriginalScopes;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=sourcemap-codec.umd.js.map\n","import { encode } from '@jridgewell/sourcemap-codec';\n\nclass BitSet {\n\tconstructor(arg) {\n\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t}\n\n\tadd(n) {\n\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t}\n\n\thas(n) {\n\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t}\n}\n\nclass Chunk {\n\tconstructor(start, end, content) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.original = content;\n\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\n\t\tthis.content = content;\n\t\tthis.storeName = false;\n\t\tthis.edited = false;\n\n\t\t{\n\t\t\tthis.previous = null;\n\t\t\tthis.next = null;\n\t\t}\n\t}\n\n\tappendLeft(content) {\n\t\tthis.outro += content;\n\t}\n\n\tappendRight(content) {\n\t\tthis.intro = this.intro + content;\n\t}\n\n\tclone() {\n\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t}\n\n\tcontains(index) {\n\t\treturn this.start < index && index < this.end;\n\t}\n\n\teachNext(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.next;\n\t\t}\n\t}\n\n\teachPrevious(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t}\n\n\tedit(content, storeName, contentOnly) {\n\t\tthis.content = content;\n\t\tif (!contentOnly) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t}\n\n\tprependLeft(content) {\n\t\tthis.outro = content + this.outro;\n\t}\n\n\tprependRight(content) {\n\t\tthis.intro = content + this.intro;\n\t}\n\n\treset() {\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\t\tif (this.edited) {\n\t\t\tthis.content = this.original;\n\t\t\tthis.storeName = false;\n\t\t\tthis.edited = false;\n\t\t}\n\t}\n\n\tsplit(index) {\n\t\tconst sliceIndex = index - this.start;\n\n\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\tthis.original = originalBefore;\n\n\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif (this.edited) {\n\t\t\t// after split we should save the edit content record into the correct chunk\n\t\t\t// to make sure sourcemap correct\n\t\t\t// For example:\n\t\t\t// '  test'.trim()\n\t\t\t//     split   -> '  ' + 'test'\n\t\t\t//   ✔️ edit    -> '' + 'test'\n\t\t\t//   ✖️ edit    -> 'test' + ''\n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit('', false);\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t}\n\n\ttoString() {\n\t\treturn this.intro + this.content + this.outro;\n\t}\n\n\ttrimEnd(rx) {\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t\tif (this.edited) {\n\t\t\t\t\t// save the change, if it has been edited\n\t\t\t\t\tthis.edit(trimmed, this.storeName, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\t\t}\n\t}\n\n\ttrimStart(rx) {\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tconst newChunk = this.split(this.end - trimmed.length);\n\t\t\t\tif (this.edited) {\n\t\t\t\t\t// save the change, if it has been edited\n\t\t\t\t\tnewChunk.edit(trimmed, this.storeName, true);\n\t\t\t\t}\n\t\t\t\tthis.edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\t\t}\n\t}\n}\n\nfunction getBtoa() {\n\tif (typeof globalThis !== 'undefined' && typeof globalThis.btoa === 'function') {\n\t\treturn (str) => globalThis.btoa(unescape(encodeURIComponent(str)));\n\t} else if (typeof Buffer === 'function') {\n\t\treturn (str) => Buffer.from(str, 'utf-8').toString('base64');\n\t} else {\n\t\treturn () => {\n\t\t\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n\t\t};\n\t}\n}\n\nconst btoa = /*#__PURE__*/ getBtoa();\n\nclass SourceMap {\n\tconstructor(properties) {\n\t\tthis.version = 3;\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = encode(properties.mappings);\n\t\tif (typeof properties.x_google_ignoreList !== 'undefined') {\n\t\t\tthis.x_google_ignoreList = properties.x_google_ignoreList;\n\t\t}\n\t\tif (typeof properties.debugId !== 'undefined') {\n\t\t\tthis.debugId = properties.debugId;\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this);\n\t}\n\n\ttoUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n}\n\nfunction guessIndent(code) {\n\tconst lines = code.split('\\n');\n\n\tconst tabbed = lines.filter((line) => /^\\t+/.test(line));\n\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tconst min = spaced.reduce((previous, current) => {\n\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n\nfunction getRelativePath(from, to) {\n\tconst fromParts = from.split(/[/\\\\]/);\n\tconst toParts = to.split(/[/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tlet i = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n\nconst toString = Object.prototype.toString;\n\nfunction isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n\nfunction getLocator(source) {\n\tconst originalLines = source.split('\\n');\n\tconst lineOffsets = [];\n\n\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\tlineOffsets.push(pos);\n\t\tpos += originalLines[i].length + 1;\n\t}\n\n\treturn function locate(index) {\n\t\tlet i = 0;\n\t\tlet j = lineOffsets.length;\n\t\twhile (i < j) {\n\t\t\tconst m = (i + j) >> 1;\n\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\tconst line = i - 1;\n\t\tconst column = index - lineOffsets[line];\n\t\treturn { line, column };\n\t};\n}\n\nconst wordRegex = /\\w/;\n\nclass Mappings {\n\tconstructor(hires) {\n\t\tthis.hires = hires;\n\t\tthis.generatedCodeLine = 0;\n\t\tthis.generatedCodeColumn = 0;\n\t\tthis.raw = [];\n\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\tthis.pending = null;\n\t}\n\n\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\tif (content.length) {\n\t\t\tconst contentLengthMinusOne = content.length - 1;\n\t\t\tlet contentLineEnd = content.indexOf('\\n', 0);\n\t\t\tlet previousContentLineEnd = -1;\n\t\t\t// Loop through each line in the content and add a segment, but stop if the last line is empty,\n\t\t\t// else code afterwards would fill one line too many\n\t\t\twhile (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {\n\t\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\t\tif (nameIndex >= 0) {\n\t\t\t\t\tsegment.push(nameIndex);\n\t\t\t\t}\n\t\t\t\tthis.rawSegments.push(segment);\n\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\n\t\t\t\tpreviousContentLineEnd = contentLineEnd;\n\t\t\t\tcontentLineEnd = content.indexOf('\\n', contentLineEnd + 1);\n\t\t\t}\n\n\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\tsegment.push(nameIndex);\n\t\t\t}\n\t\t\tthis.rawSegments.push(segment);\n\n\t\t\tthis.advance(content.slice(previousContentLineEnd + 1));\n\t\t} else if (this.pending) {\n\t\t\tthis.rawSegments.push(this.pending);\n\t\t\tthis.advance(content);\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\tlet originalCharIndex = chunk.start;\n\t\tlet first = true;\n\t\t// when iterating each char, check if it's in a word boundary\n\t\tlet charInHiresBoundary = false;\n\n\t\twhile (originalCharIndex < chunk.end) {\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\tfirst = true;\n\t\t\t\tcharInHiresBoundary = false;\n\t\t\t} else {\n\t\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\n\t\t\t\t\tif (this.hires === 'boundary') {\n\t\t\t\t\t\t// in hires \"boundary\", group segments per word boundary than per char\n\t\t\t\t\t\tif (wordRegex.test(original[originalCharIndex])) {\n\t\t\t\t\t\t\t// for first char in the boundary found, start the boundary by pushing a segment\n\t\t\t\t\t\t\tif (!charInHiresBoundary) {\n\t\t\t\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t\t\t\t\tcharInHiresBoundary = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// for non-word char, end the boundary by pushing a segment\n\t\t\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t\t\t\tcharInHiresBoundary = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tloc.column += 1;\n\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\tadvance(str) {\n\t\tif (!str) return;\n\n\t\tconst lines = str.split('\\n');\n\n\t\tif (lines.length > 1) {\n\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t}\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t}\n\n\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t}\n}\n\nconst n = '\\n';\n\nconst warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false,\n};\n\nclass MagicString {\n\tconstructor(string, options = {}) {\n\t\tconst chunk = new Chunk(0, string.length, string);\n\n\t\tObject.defineProperties(this, {\n\t\t\toriginal: { writable: true, value: string },\n\t\t\toutro: { writable: true, value: '' },\n\t\t\tintro: { writable: true, value: '' },\n\t\t\tfirstChunk: { writable: true, value: chunk },\n\t\t\tlastChunk: { writable: true, value: chunk },\n\t\t\tlastSearchedChunk: { writable: true, value: chunk },\n\t\t\tbyStart: { writable: true, value: {} },\n\t\t\tbyEnd: { writable: true, value: {} },\n\t\t\tfilename: { writable: true, value: options.filename },\n\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\tsourcemapLocations: { writable: true, value: new BitSet() },\n\t\t\tstoredNames: { writable: true, value: {} },\n\t\t\tindentStr: { writable: true, value: undefined },\n\t\t\tignoreList: { writable: true, value: options.ignoreList },\n\t\t\toffset: { writable: true, value: options.offset || 0 },\n\t\t});\n\n\t\tthis.byStart[0] = chunk;\n\t\tthis.byEnd[string.length] = chunk;\n\t}\n\n\taddSourcemapLocation(char) {\n\t\tthis.sourcemapLocations.add(char);\n\t}\n\n\tappend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t}\n\n\tappendLeft(index, content) {\n\t\tindex = index + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendLeft(content);\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\t\treturn this;\n\t}\n\n\tappendRight(index, content) {\n\t\tindex = index + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendRight(content);\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst cloned = new MagicString(this.original, { filename: this.filename, offset: this.offset });\n\n\t\tlet originalChunk = this.firstChunk;\n\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\twhile (originalChunk) {\n\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif (nextClonedChunk) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\tcloned.intro = this.intro;\n\t\tcloned.outro = this.outro;\n\n\t\treturn cloned;\n\t}\n\n\tgenerateDecodedMap(options) {\n\t\toptions = options || {};\n\n\t\tconst sourceIndex = 0;\n\t\tconst names = Object.keys(this.storedNames);\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tconst locate = getLocator(this.original);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.firstChunk.eachNext((chunk) => {\n\t\t\tconst loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tmappings.addEdit(\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tchunk.content,\n\t\t\t\t\tloc,\n\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : undefined,\n\t\t\tsources: [\n\t\t\t\toptions.source ? getRelativePath(options.file || '', options.source) : options.file || '',\n\t\t\t],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : undefined,\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t\tx_google_ignoreList: this.ignoreList ? [sourceIndex] : undefined,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\t_ensureindentStr() {\n\t\tif (this.indentStr === undefined) {\n\t\t\tthis.indentStr = guessIndent(this.original);\n\t\t}\n\t}\n\n\t_getRawIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr;\n\t}\n\n\tgetIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t}\n\n\tindent(indentStr, options) {\n\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tif (indentStr === undefined) {\n\t\t\tthis._ensureindentStr();\n\t\t\tindentStr = this.indentStr || '\\t';\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tconst isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tconst exclusions =\n\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach((exclusion) => {\n\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\tconst replacer = (match) => {\n\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tlet charIndex = 0;\n\t\tlet chunk = this.firstChunk;\n\n\t\twhile (chunk) {\n\t\t\tconst end = chunk.end;\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t}\n\n\tinsert() {\n\t\tthrow new Error(\n\t\t\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)',\n\t\t);\n\t}\n\n\tinsertLeft(index, content) {\n\t\tif (!warned.insertLeft) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead',\n\t\t\t);\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft(index, content);\n\t}\n\n\tinsertRight(index, content) {\n\t\tif (!warned.insertRight) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead',\n\t\t\t);\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight(index, content);\n\t}\n\n\tmove(start, end, index) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\t\tindex = index + this.offset;\n\n\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\t\tthis._split(index);\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tconst oldLeft = first.previous;\n\t\tconst oldRight = last.next;\n\n\t\tconst newRight = this.byStart[index];\n\t\tif (!newRight && last === this.lastChunk) return this;\n\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\tif (newLeft) newLeft.next = first;\n\t\tif (newRight) newRight.previous = last;\n\n\t\tif (!first.previous) this.firstChunk = last.next;\n\t\tif (!last.next) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight || null;\n\n\t\tif (!newLeft) this.firstChunk = first;\n\t\tif (!newRight) this.lastChunk = last;\n\t\treturn this;\n\t}\n\n\toverwrite(start, end, content, options) {\n\t\toptions = options || {};\n\t\treturn this.update(start, end, content, { ...options, overwrite: !options.contentOnly });\n\t}\n\n\tupdate(start, end, content, options) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\tif (start === end)\n\t\t\tthrow new Error(\n\t\t\t\t'Cannot overwrite a zero-length range – use appendLeft or prependRight instead',\n\t\t\t);\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tif (options === true) {\n\t\t\tif (!warned.storeName) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string',\n\t\t\t\t);\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\tconst overwrite = options !== undefined ? options.overwrite : false;\n\n\t\tif (storeName) {\n\t\t\tconst original = this.original.slice(start, end);\n\t\t\tObject.defineProperty(this.storedNames, original, {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: true,\n\t\t\t\tenumerable: true,\n\t\t\t});\n\t\t}\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tif (first) {\n\t\t\tlet chunk = first;\n\t\t\twhile (chunk !== last) {\n\t\t\t\tif (chunk.next !== this.byStart[chunk.end]) {\n\t\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t\t}\n\t\t\t\tchunk = chunk.next;\n\t\t\t\tchunk.edit('', false);\n\t\t\t}\n\n\t\t\tfirst.edit(content, storeName, !overwrite);\n\t\t} else {\n\t\t\t// must be inserting at the end\n\t\t\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\t\treturn this;\n\t}\n\n\tprepend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t}\n\n\tprependLeft(index, content) {\n\t\tindex = index + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependLeft(content);\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\t\treturn this;\n\t}\n\n\tprependRight(index, content) {\n\t\tindex = index + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependRight(content);\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\t\treturn this;\n\t}\n\n\tremove(start, end) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit('');\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\t\treturn this;\n\t}\n\n\treset(start, end) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.reset();\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\t\treturn this;\n\t}\n\n\tlastChar() {\n\t\tif (this.outro.length) return this.outro[this.outro.length - 1];\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n\t\t\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\n\t\t\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n\t\t} while ((chunk = chunk.previous));\n\t\tif (this.intro.length) return this.intro[this.intro.length - 1];\n\t\treturn '';\n\t}\n\n\tlastLine() {\n\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n\t\tlet lineStr = this.outro;\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.content.length > 0) {\n\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t}\n\t\t} while ((chunk = chunk.previous));\n\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n\t\treturn this.intro + lineStr;\n\t}\n\n\tslice(start = 0, end = this.original.length - this.offset) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tlet result = '';\n\n\t\t// find start chunk\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t// found end chunk before start\n\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\tconst startChunk = chunk;\n\t\twhile (chunk) {\n\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif (containsEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// TODO deprecate this? not really very useful\n\tsnip(start, end) {\n\t\tconst clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t}\n\n\t_split(index) {\n\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\tlet chunk = this.lastSearchedChunk;\n\t\tconst searchForward = index > chunk.end;\n\n\t\twhile (chunk) {\n\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\t\t}\n\t}\n\n\t_splitChunk(chunk, index) {\n\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${chunk.original}\")`,\n\t\t\t);\n\t\t}\n\n\t\tconst newChunk = chunk.split(index);\n\n\t\tthis.byEnd[index] = chunk;\n\t\tthis.byStart[index] = newChunk;\n\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\tlet str = this.intro;\n\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t}\n\n\tisEmpty() {\n\t\tlet chunk = this.firstChunk;\n\t\tdo {\n\t\t\tif (\n\t\t\t\t(chunk.intro.length && chunk.intro.trim()) ||\n\t\t\t\t(chunk.content.length && chunk.content.trim()) ||\n\t\t\t\t(chunk.outro.length && chunk.outro.trim())\n\t\t\t)\n\t\t\t\treturn false;\n\t\t} while ((chunk = chunk.next));\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\tlet chunk = this.firstChunk;\n\t\tlet length = 0;\n\t\tdo {\n\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t} while ((chunk = chunk.next));\n\t\treturn length;\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimEndAborted(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tlet chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif (chunk.end !== end) {\n\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.previous;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimEnd(charType) {\n\t\tthis.trimEndAborted(charType);\n\t\treturn this;\n\t}\n\ttrimStartAborted(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tlet chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\tif (chunk.end !== end) {\n\t\t\t\t// special case...\n\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.next;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimStart(charType) {\n\t\tthis.trimStartAborted(charType);\n\t\treturn this;\n\t}\n\n\thasChanged() {\n\t\treturn this.original !== this.toString();\n\t}\n\n\t_replaceRegexp(searchValue, replacement) {\n\t\tfunction getReplacement(match, str) {\n\t\t\tif (typeof replacement === 'string') {\n\t\t\t\treturn replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {\n\t\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\n\t\t\t\t\tif (i === '$') return '$';\n\t\t\t\t\tif (i === '&') return match[0];\n\t\t\t\t\tconst num = +i;\n\t\t\t\t\tif (num < match.length) return match[+i];\n\t\t\t\t\treturn `$${i}`;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn replacement(...match, match.index, str, match.groups);\n\t\t\t}\n\t\t}\n\t\tfunction matchAll(re, str) {\n\t\t\tlet match;\n\t\t\tconst matches = [];\n\t\t\twhile ((match = re.exec(str))) {\n\t\t\t\tmatches.push(match);\n\t\t\t}\n\t\t\treturn matches;\n\t\t}\n\t\tif (searchValue.global) {\n\t\t\tconst matches = matchAll(searchValue, this.original);\n\t\t\tmatches.forEach((match) => {\n\t\t\t\tif (match.index != null) {\n\t\t\t\t\tconst replacement = getReplacement(match, this.original);\n\t\t\t\t\tif (replacement !== match[0]) {\n\t\t\t\t\t\tthis.overwrite(match.index, match.index + match[0].length, replacement);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tconst match = this.original.match(searchValue);\n\t\t\tif (match && match.index != null) {\n\t\t\t\tconst replacement = getReplacement(match, this.original);\n\t\t\t\tif (replacement !== match[0]) {\n\t\t\t\t\tthis.overwrite(match.index, match.index + match[0].length, replacement);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t_replaceString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst index = original.indexOf(string);\n\n\t\tif (index !== -1) {\n\t\t\tthis.overwrite(index, index + string.length, replacement);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplace(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceString(searchValue, replacement);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n\n\t_replaceAllString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst stringLength = string.length;\n\t\tfor (\n\t\t\tlet index = original.indexOf(string);\n\t\t\tindex !== -1;\n\t\t\tindex = original.indexOf(string, index + stringLength)\n\t\t) {\n\t\t\tconst previous = original.slice(index, index + stringLength);\n\t\t\tif (previous !== replacement) this.overwrite(index, index + stringLength, replacement);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplaceAll(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceAllString(searchValue, replacement);\n\t\t}\n\n\t\tif (!searchValue.global) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'MagicString.prototype.replaceAll called with a non-global RegExp argument',\n\t\t\t);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n}\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nclass Bundle {\n\tconstructor(options = {}) {\n\t\tthis.intro = options.intro || '';\n\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\tthis.sources = [];\n\t\tthis.uniqueSources = [];\n\t\tthis.uniqueSourceIndexByFilename = {};\n\t}\n\n\taddSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator,\n\t\t\t});\n\t\t}\n\n\t\tif (!isObject(source) || !source.content) {\n\t\t\tthrow new Error(\n\t\t\t\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`',\n\t\t\t);\n\t\t}\n\n\t\t['filename', 'ignoreList', 'indentExclusionRanges', 'separator'].forEach((option) => {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t}\n\n\tappend(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: (options && options.separator) || '',\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator,\n\t\t});\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator,\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t}\n\n\tgenerateDecodedMap(options = {}) {\n\t\tconst names = [];\n\t\tlet x_google_ignoreList = undefined;\n\t\tthis.sources.forEach((source) => {\n\t\t\tObject.keys(source.content.storedNames).forEach((name) => {\n\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tmappings.advance(this.separator);\n\t\t\t}\n\n\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\tconst magicString = source.content;\n\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\tif (magicString.intro) {\n\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t}\n\n\t\t\tmagicString.firstChunk.eachNext((chunk) => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (source.filename) {\n\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tmagicString.sourcemapLocations,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\tif (magicString.outro) {\n\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t}\n\n\t\t\tif (source.ignoreList && sourceIndex !== -1) {\n\t\t\t\tif (x_google_ignoreList === undefined) {\n\t\t\t\t\tx_google_ignoreList = [];\n\t\t\t\t}\n\t\t\t\tx_google_ignoreList.push(sourceIndex);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : undefined,\n\t\t\tsources: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t\tx_google_ignoreList,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\tconst indentStringCounts = {};\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tconst indentStr = source.content._getRawIndentString();\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn (\n\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t})[0] || '\\t'\n\t\t);\n\t}\n\n\tindent(indentStr) {\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart, //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro =\n\t\t\t\tindentStr +\n\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst body = this.sources\n\t\t\t.map((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\treturn str;\n\t\t\t})\n\t\t\t.join('');\n\n\t\treturn this.intro + body;\n\t}\n\n\tisEmpty() {\n\t\tif (this.intro.length && this.intro.trim()) return false;\n\t\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\treturn this.sources.reduce(\n\t\t\t(length, source) => length + source.content.length(),\n\t\t\tthis.intro.length,\n\t\t);\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimStart(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tlet source;\n\t\t\tlet i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i++];\n\t\t\t\tif (!source) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\ttrimEnd(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tlet source;\n\t\tlet i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this.sources[i--];\n\t\t\tif (!source) {\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\treturn this;\n\t}\n}\n\nexport { Bundle, SourceMap, MagicString as default };\n//# sourceMappingURL=magic-string.es.mjs.map\n"],"names":["global","factory","exports","this","chars","intToChar","charToInt","i","c","decodeInteger","reader","relative","value","shift","integer","shouldNegate","encodeInteger","builder","num","delta","clamped","hasMoreVlq","max","bufLength","td","buf","out","StringWriter","v","buffer","pos","StringReader","char","idx","EMPTY","decodeOriginalScopes","input","length","scopes","stack","line","column","last","kind","scope","vars","varsIndex","encodeOriginalScopes","writer","_encodeOriginalScopes","index","state","startLine","startColumn","endLine","endColumn","fields","next","l","decodeGeneratedRanges","ranges","genLine","definitionSourcesIndex","definitionScopeIndex","callsiteSourcesIndex","callsiteLine","callsiteColumn","bindingLine","bindingColumn","semi","genColumn","hasDefinition","hasCallsite","hasScope","callsite","bindings","range","defSourcesIndex","prevCsi","prevLine","sameSource","expressionsCount","expressionRanges","prevBl","expression","encodeGeneratedRanges","_encodeGeneratedRanges","isScope","catchupLine","sourcesIndex","scopesIndex","callLine","callColumn","binding","bindingStartLine","bindingStartColumn","expRange","lastLine","decode","mappings","decoded","sourceLine","sourceColumn","namesIndex","sorted","lastCol","seg","sort","sortComparator","b","encode","j","segment","BitSet","arg","n","Chunk","start","end","content","chunk","fn","storeName","contentOnly","sliceIndex","originalBefore","originalAfter","newChunk","rx","trimmed","getBtoa","str","btoa","SourceMap","properties","guessIndent","code","lines","tabbed","spaced","min","previous","current","numSpaces","getRelativePath","from","to","fromParts","toParts","toString","isObject","thing","getLocator","source","originalLines","lineOffsets","m","wordRegex","Mappings","hires","sourceIndex","loc","nameIndex","contentLengthMinusOne","contentLineEnd","previousContentLineEnd","original","sourcemapLocations","originalCharIndex","first","charInHiresBoundary","warned","MagicString","string","options","cloned","originalChunk","clonedChunk","nextOriginalChunk","nextClonedChunk","names","locate","indentStr","pattern","isExcluded","exclusion","shouldIndentNextCharacter","replacer","match","charIndex","oldLeft","oldRight","newRight","newLeft","overwrite","lineIndex","lineStr","result","startChunk","containsEnd","sliceStart","sliceEnd","clone","searchForward","charType","aborted","searchValue","replacement","getReplacement","_","matchAll","re","matches","stringLength"],"mappings":"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","x_google_ignoreList":[0,1]}